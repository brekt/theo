<!DOCTYPE html>
<html>
<body>
  <script src="./dist/vendor/three.min.js"></script>
  <script>
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 10000);
  camera.position.z = 1000;
  const renderer = new THREE.WebGLRenderer();
  const material = new THREE.MeshBasicMaterial({color: 0xfffff, wireframe: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  class Polyhedron {
    constructor(faceCount = 6, radius = 512, detail=0) {
      this.faceCount = faceCount;
      this.radius = radius;
      switch (faceCount) {
        case 4:
          this.vertexCount = 4;
          this.edgeCount = 6;
					this.geometry = new THREE.TetrahedronGeometry(radius, detail);
          break;
        case 5:
          this.vertexCount = 5;
          this.edgeCount = 8;
					this.geometry = new THREE.Geometry();
					this.geometry.vertices = [
    				new THREE.Vector3(-0.5, -0.5, 0),
    				new THREE.Vector3(-0.5, 0.5, 0),
    				new THREE.Vector3(0.5, 0.5, 0),
    				new THREE.Vector3(0.5, -0.5, 0),
    				new THREE.Vector3(0, 0, 1)
					];
					this.geometry.faces = [
				    new THREE.Face3(0, 1, 2),
				    new THREE.Face3(0, 2, 3),
				    new THREE.Face3(1, 0, 4),
				    new THREE.Face3(2, 1, 4),
				    new THREE.Face3(3, 2, 4),
				    new THREE.Face3(0, 3, 4)
					];
					this.transformation = new THREE.Matrix4().makeScale(radius, radius, radius);
					this.geometry.applyMatrix(this.transformation);
          break;
        case 6:
          this.vertexCount = 8;
          this.edgeCount = 12;
          this.geometry = new THREE.BoxGeometry(radius, radius, radius);
          break;
        case 7:
          this.vertexCount = 10;
          this.edgeCount = 15;
          this.geometry = new THREE.Geometry();
          const segLength = 0.5;
          const ang = 2 * Math.PI / 5;
          const yAxis = new THREE.Vector3(0, 1, 0);
          const ver0 = new THREE.Vector3(0, segLength, segLength);
          const yShift = new THREE.Vector3(0, -1 * segLength, 0);
          this.geometry.vertices = [
            ver0,
            ver0.clone().applyAxisAngle(yAxis, ang),
            ver0.clone().applyAxisAngle(yAxis, 2 * ang),
            ver0.clone().applyAxisAngle(yAxis, 3 * ang),
            ver0.clone().applyAxisAngle(yAxis, 4 * ang),
            ver0.clone().add(yShift),
            ver0.clone().add(yShift).applyAxisAngle(yAxis, ang),
            ver0.clone().add(yShift).applyAxisAngle(yAxis, 2 * ang),
            ver0.clone().add(yShift).applyAxisAngle(yAxis, 3 * ang),
            ver0.clone().add(yShift).applyAxisAngle(yAxis, 4 * ang),
          ];
          this.geometry.faces = [
            new THREE.Face3(0, 1, 2),
            new THREE.Face3(0, 2, 3),
            new THREE.Face3(0, 3, 4),
            new THREE.Face3(0, 1, 5),
            new THREE.Face3(1, 5, 6),
            new THREE.Face3(1, 2, 7),
            new THREE.Face3(1, 6, 7),
            new THREE.Face3(2, 3, 7),
            new THREE.Face3(3, 7, 8),
            new THREE.Face3(3, 4, 8),
            new THREE.Face3(4, 8, 9),
            new THREE.Face3(0, 4, 9),
            new THREE.Face3(0, 5, 9),
            new THREE.Face3(5, 6, 7),
            new THREE.Face3(5, 7, 8),
            new THREE.Face3(5, 8, 9)
          ];
          this.transformation = new THREE.Matrix4().makeScale(radius, radius, radius);
          this.geometry.applyMatrix(this.transformation);
          break;
        case 8:
          this.vertexCount = 6;
          this.edgeCount = 12;
          break;
        case 9:
          break;
        case 10:
          break;
        case 11:
          break;
        case 12:
          break;
        default:
          // cube
          this.vertexCount = 8;
          this.edgeCount = 12;
        }
				this.mesh = new THREE.Mesh(this.geometry, material);
      }
    }
		const poly = new Polyhedron(7, 512);
    scene.add(poly.mesh);
    function render() {
      requestAnimationFrame(render);
      poly.mesh.rotation.x += 0.001;
      poly.mesh.rotation.y += 0.001;
      renderer.render(scene, camera);
    }
    render();
  </script>
</body>
</html>
